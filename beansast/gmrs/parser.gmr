(* GRAMMAR'S SYNTAX
 every statement must end with `;'

 /Rules/
 Rules follow a simplified version of BNF
 Basically place a terminal or non-terminals one after the other
 A non-terminal may be composed of many rules; split them with `:' (COLON)
 put an `;' (SEMICOLON) at the end of a non-terminal definition
 after a terminal or non-terminal in a rule, you may specify it's
 key so it can be stored after the parsing with `@' + key
   - Example ::= : TERMINAL NonTerminal@key <>; *)

IfStatement ::=
 : IF Expression@test Statement@then <haselse: False>
 : IF Expression@test Statement@then ELSE Statement@else <haselse: True>
;

WhileStatement ::=
 : WHILE Expression@test Statement@do <>
;

Declaration ::=
 : ID.name@type ID.name@key <>
;

Assignment ::=
 : ID.name@key EQUALS Expression@value <type: "[None]">
 : ID.name@type ID.name@key EQUALS Expression@value <>
;

BuiltinTypes ::=
 : INT.value@value <type: "int", op: "builtin">
 : STRING.value@value <type: "string", op: "builtin">
 : ID.name@value <type: "id", op: "builtin">
 : TRUE <type: "true", op: "builtin">
 : FALSE <type: "false", op: "builtin">
;

Atom ::=
 : BuiltinTypes@this <>
 : LPAR Expression@this RPAR <>
;

Equality ::=
 : Equality@left EQ Comparison@right <op: "eq">
 : Equality@left NE Comparison@right <op: "ne">
 : Comparison@this <>
;

Comparison ::=
 : Comparison@left GE Sum@right <op: "ge">
 : Comparison@left GT Sum@right <op: "gt">
 : Comparison@left LE Sum@right <op: "le">
 : Comparison@left LT Sum@right <op: "lt">
 : Sum@this <>
;

Sum ::=
 : Sum@left PLUS Product@right <op: "add">
 : Sum@left MINUS Product@right <op: "sub">
 : Product@this <>
;

Product ::=
 : Product@left ASTERISK Unary@right <op: "mul">
 : Product@left SLASH Unary@right <op: "div">
 : Product@left DSLASH Unary@right <op: "tdiv">
 : Product@left PERCENTAGE Unary@right <op: "mod">
 : Unary@this <>
;

Unary ::=
 : TILDE Unary@right <op: "com">
 : PLUS Unary@right <op: "pls">
 : MINUS Unary@right <op: "min">
 : Power@this <>
;

Power ::=
 : Power@left DASTERISK Atom@right <op: "pow">
 : Atom@this <>
;

Expression ::=
 : Equality@this <>
 : Statement@frame <op: "frame">
;

Statement ::=
 : Assignment@this SEMICOLON <s: 'assign'>
 : Declaration@this SEMICOLON <s: 'declare'>
 : IfStatement@this <s: 'test'>
 : WhileStatement@this <s: 'do'>
 : LBRACE StatementList@this RBRACE <>
 : RETURN Expression@this SEMICOLON <s: 'return'>
;

@StatementList ::=
 : StatementList@left Statement@right <s: 'concatenate'>
 : Statement@this <>
;